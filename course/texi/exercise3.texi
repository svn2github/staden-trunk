@node X3
@chapter Sequencing Project Creation, Automatic Contig Assembly and Contig editing

@node X3-obj
@section The Objectives of the Practical

These step by step instructions are intended to get you through the mechanics
of using the programs to produce the required results. The bare minimum of
explanation will be offered as you proceed. At various stages in the exercises
you will be referred to the on-line manual for the relevant programs which
will provide a much fuller explanation of what you have done and why.


@node X3-overview
@section An Overview of the Practical Session

The stages of the exercise are:

@enumerate
@item Automatic assembly of shotgun readings into a new sequencing project database.
@item Contiguation.
@item Finishing.
@end enumerate

@node X3-data
@section Obtaining a Data Set for this Excercise

In this exercise, the first intention is to look at contig assembly. To do
this sensibly, we require a similar set of data to the previous exercise. In
fact, it is the same data, but processed using an older copy of the
software. This is purely due to improvements in the pre-processing stages;
using the newest pregap4 would invalidate these course notes and rewriting
them all is not a minor task!

_ifdef([[_unix]],[[Firstly we need to create another new directory to copy the
data to. Once again this will be a subdirectory of our home directory. You
should all know how to do this now so in condensed form:

@example
cd
mkdir exercise3
cd exercise3
@end example

This has created a new directory named @b{exercise3} which is now our current
directory. Into this directory we wish to copy files from
@b{$STADENROOT/course/data/shotgun_data}:

@example
cp $STADENROOT/course/data/shotgun_data/* .
ls
@end example

You will have copied just under 100 ZTR trace files
and experiment files. The @b{ls} command will have revealed lots of Experiment
file (@b{*.exp}) and ZTR files (@b{*.ztr}). The experiment files were
generated by using pregap4 on the ZTR files, in much the same way to the
previous exercise. The @b{ls} will also have revealed the pregap4 output
files, named pregap.*.  ]])_ifdef([[_windows]],[[Firstly we need to create a
new folder for ourselves using the explorer window. It doesn't matter where
this is, but I suggest you choose a directory within your own `home' area and
call it @b{assembly_test}. Throughout the notes when we refer to
@b{assembly_test} we mean this newly created folder. It is not a good idea to
simply modify the original copies of the course data as this may then require
reinstalling the package if you need to rerun this tutorial.

Next we need to copy the data from the @b{course/data/shotgun_data}
subdirectory of the Staden Package installation. Use the @b{explorer} window
to move to the location of this directory. Then press @b{Control-A} to
highlight everything; @b{Control-C} to "copy" these into the Windows
cut-buffer; change the view back to your @b{assembly_test} folder; and finally
@b{Control-V} to "paste" the files into @b{assembly_test}.

After lots of annoying flying document animations you will have copied just
under 100 ZTR trace files and experiment files. The experiment files were
generated by using pregap4 on the ZTR files, in much the same way to the
previous exercise.]])

@node X3-gap4
@section Starting up gap4 and creating a sequencing project database

_ifdef([[_unix]],[[Start up gap4:

@example
gap4 &
@end example
]])_ifdef([[_windows]],[[Start up the gap4 program. This is in the @b{Start}
menu under @b{Staden Package} @result{} @b{Gap4}]])

Before we proceed further we need to create a new gap4 database. Click on the
@b{File} menu and select @b{New} as you wish to create a new sequencing
project database. A small dialogue window will appear and ask you:

@example
Enter new filename
@end example

You are being asked for a name for your new sequencing project database, which
is a little more than a simple file, but never mind. We need this project
database to be in the same folder as our experiment and ZTR files.
_ifdef([[_unix]],[[We could press the browse button at this point, but there
is little need as we do not yet have a database name to double-click
on. Instead type in @b{course_db} as the database name and hit return. Try
switching back to your UNIX shell window to verify gap4's actions:

@example
ls -ltr
@end example

You should see the following new files:]])_ifdef([[_windows]],[[We could type
in the full pathname at this point, but I suggest that you click on the Browse
button. This will pop up a file browser which you should use to change to your
assembly_test directory. We do not yet have a database file to double-click
on, but try typing @b{course_db} into the @b{File name:} prompt and hit
return. This will fill out the box in the gap4 @i{Enter new filename} query,
so you can just click on @b{OK} there to dismiss the dialogue. Gap4 should
inform you that it has changed folder by issuing a small amount of UNIX-speak
into the text output window, for example:

@example
Changing directory to C:/users/jkb/assembly_test
@end example

Now try switching to an explorer window to verify that gap4's boasts are for
real. Looking in the @b{assembly_test} directory you should see the following
new files:]])

@example
course_db.0
course_db.0.BUSY
course_db.0.aux
course_db.0.log
@end example

The first and third of these files comprise version @b{0} of the database
called @b{course_db}. The other two, as described in the previous exercise,
indicate that this database is currently being edited (the @b{BUSY} file), and
a brief history of actions performed (the @b{log} file).

@node X3-assembly
@section Automatically assembling the test readings into contigs

You are now ready to automatically assemble your sequences. From the
@b{Assembly} pull down menu, select the @b{Normal shotgun assembly}
option. gap4 offers you a choice of assembly strategies. The other options
will be discussed elsewhere@footnote{However, should you not wish to wait, try
clicking on the nearest Help button. Your web browser will leap to the section
on "@i{Normal Shotgun Assembly}". If you move back a section from here (click
on the web page @b{prev} button) you will be offered the opportunity to read
the wise words concerning all the other assembly strategies.}. A form window
will appear allowing you to set all the parameters relevant to a @i{Normal
shotgun assembly}. We will demonstrate all the ways in which you can enter
values into this kind of form, and we will discuss the various parameters to
be set at that point.

@enumerate
@item
At the top of the form is the @b{Apply masking} section. You can either do it
... or not. The current selection is indicated by a
_ifdef([[_unix]],[[shaded diamond]]) _ifdef([[_windows]],[[circle with a dot in it]]) (@b{No}, in this case). Click (left mouse button) on the @b{Yes} and @b{No}
_ifdef([[_unix]],[[diamond]])[[]]_ifdef([[_windows]],[[circle]]) selectors
indecisively for a little while. Note that were you to select @b{Yes}, you
would need to @b{Select tags}. If you click on the @b{Select tags} button
whilst in @b{Yes} mode, you will get a new window offering the gap4 selection
of standard tags.

You are being offered the opportunity to ignore tagged regions of your contigs
during assembly. So, for example, had you tagged sections of your contigs as
ALU repeats (by using pregap4, for example), then you could request that such
regions are ignored whilst new data is being assembled. This could well be a
good strategy, avoiding the possibility of new reads including ALU repeats
being entered into inappropriate contigs.

For this exercise, end your clicking with a @b{No} in the @b{Apply Masking}
section. To keep your screen tidy, make sure you @b{Cancel} your @i{Active
tags} window.

@image{gap4-assem,3in}

@item
In the next section down, you are invited to @b{Select Display Mode}. Click on
the @b{Show all alignments} button.

In normal circumstances, this log is not vital, so the default @b{Hide all
alignments} would be appropriate. However, looking at the log does help to
understand the way gap4 processes new readings and fits them into the contigs
of a sequencing project database. So for this exercise, select the most
verbose alternative.

@item
Move now to the next section of the form. gap4's first move when looking for a
contig into which a new reading might fit is to try and find exactly matching
regions between the new reading and each current consensus sequence of the
database. gap4 asks for a minimum size for such a match. This is the
@b{Minimum initial match} requested at the top of this section. The default is
@b{20}. You can choose any value between 14 and 300. Any value around the
bottom end of this range would have a similar effect. For this exercise, set
the @b{Minimum initial match} to @b{20}. As this is the default value, you
could just leave things as they are@footnote{Generally, you can select a new
value either by typing it into the appropriate box, or by fiddling around with
the slider thing just to the right of the display of the current @b{Minimum
initial match} value. The slider is more fun, but typing in is more reliable
(particularly for parameters with a large value range and/or after a hard
night). If you are not already familiar with this sort of value selection
device, try adjusting the @b{Minimum initial match} randomly using both
methods, ending up with the value @b{20} selected.}. By choosing 20, you
are asking gap4 to investigate the possibility of fitting a reading into a
contig whenever 20 or more contiguous bases of the reading are found to
exactly match a region of the consensus sequence of that contig.

@item
Just below the Minimum initial match query, gap4 asks for the @b{Maximum pads
per read}. This can be any number between 0 and 100 (as you can verify by
wiggling the slider from left to right), with a default suggestion of
@b{25}. Accept the default of @b{25}.

gap4 attempts to align the sequence around each 20 (or whatever you set the
Minimum initial match to be) base match found between each new reading and the
consensus sequence. The process of alignment involves the introduction of
padding characters into both the contig and the new reading. Here you are
specifying that if more than @b{25} padding characters are required in either
the new reading or in the contig consensus, then the alignment is of
insufficient quality and the new reading must not be added to the matched
contig.

@item
Just below the Maximum pads per read query, gap4 asks for the @b{Maximum
percentage mismatch}. This can be any number between 0.00 and 100.00 (as again
you can verify by wiggling the appropriate slider), with a default suggestion
of 5.00. For this part of the exercise, keep the default value of @b{5.00}.

gap4 will always succeed in getting some sort of alignment between a new
reading and a matched consensus sequence. Here you are saying that,
independent of the number of padding characters required to make the
alignment, if more than 5% of the aligned bases do not match, then the
alignment is of insufficient quality and the new reading must not be added to
the matched contig.

@item
In the next section of the form, @b{Input reading names from}, you must
specify whether the names of the experiment files to be processed are to be
read from a disc @b{file} or a gap4 temporary @b{list}. The default is a file,
as indicated. In this case, the default is fine as your experiment files are
listed in the file @b{pregap.passed} output by pregap4. So, you should leave
the selection as it is@footnote{If you did not have an appropriate file of
filenames to hand, creating a "list" would be an easy matter (as will be
demonstrated). However, it should be noted that lists are temporary affairs,
whereas files last until they are explicitly deleted. Where a record is
important, files could be more appropriate.}.

Fill in the name of the file of filenames gap4 is to use by typing in:

@example
pregap.passed
@end example

in the appropriate @b{List or filename} box. gap4 will then read off the
experiment file names of the 97 readings that passed all of pregap4's many
tests.

@item
In the next @b{Save failures to} section, you are required to specify a file
or list to record the experiment file names of those reads that gap4 is
unwilling to enter into the sequencing project database. The default selection
of a @b{file} is most appropriate, so once again leave the selectors as
they are.

Fill in the appropriate @b{List or filename} box with a suitable filename,
such as:

@example
fails.01
@end example

@item
The next section of the form invites you to decide whether to @b{Permit joins}
or not. Default is @b{Yes}. Here you are being asked if you wish to join
contigs when an overlap of sufficient quality is detected. You do, so accept
the default. You would only really wish to not join contigs when you have
reason to believe that seemingly good overlaps are likely to be spurious,
because of repeated regions in your sequence perhaps.

@item
In the final section of the form, you are asked whether you wish to @b{Reject
failures} or @b{Enter all readings} (default). We'll accept this default.

Selecting Reject failures indicates to gap4 that readings that do not meet the
specified matching criteria for inclusion into an existing contig should be
merely listed in the file or list of failed readings (the file @b{fails.01} in
this case) and not included in the sequencing project database.

Selecting Enter all readings is a way of dealing with really difficult reads
that cannot be entered into the sequencing project database without using
unacceptably loose matching criteria. For such reads, selecting Enter all
readings instructs gap4 to enter such difficult reads into the database as new
"one read" contigs. Note though that due to the iterative nature of the
assembly algorithm these "one read" contigs typically get joined back
into contigs when a subsequent sequence overlaps several contigs.
@end enumerate

At this point, you have answered, or at least considered, all the questions
gap4 has to ask. It is time to activate the "doit" button (@b{OK}) in the
usual fashion. As it goes through your reads, gap4 jerkily generates the
very complete log you requested in its @i{Output window}. When it is finally
done, the @i{contig selector} window ambles into view.

At the end of its log, gap4 will boast of how many sequences it has processed,
declare how many it got into the database, tell you how many pairs of contigs
it managed to join together and admit how many times it tried to join a pair
of contigs but failed. You should be able to tell from the information in your
gap4 @i{Output Window} that all the sequences were entered, somewhere,
into the assembly. We could verify this manually by examining the
contents of the @b{fails.01} file; we should see that it is empty.

For a more detailed report of the database status after your assembly,
select the @b{Database Information} option from the @b{View} pull down
menu. gap4 will give a report of the database status in the gap4
@i{Output window}.

Before moving on from automatic contig assembly, we will take a quick look at
how the reads have been arranged by gap4 into contigs. You have already seen
how to generate a report of the status of your database by using the Database
Information option from the View pull down menu. Now select the @b{Show
relationships} option from the @b{View} pull down menu. gap4 provides you with
another form to complete. This time:


1) The first section of the form, labelled @b{Input contigs from} mode, asks
whether you wish to process @b{single} contig, @b{all contigs}, or to read a
list of contig names from a @b{file} or @b{list}. Well you want to see how the
readings have been arranged in all your contigs, not just one specific contig,
so accept the default choice of @b{all contigs}.

2) The next section of the form asks whether you wish to @b{Show readings in
positional order}, or not. If you select the Yes option at this point, you
elect to display the readings in the database as they have been overlapped
into contigs. The No alternative is to show the readings listed in the order
in which they were entered into the database, which is really only of interest 
in special cases. Hence we will investigate the first option and make sure
that we answer @b{Yes} (the default).

The form is now ready, so click on the @b{OK} button to start things
rolling. In its Output Window, gap4 will first list information about each
contig that has been formed. For each contig the readings are listed as as
they are positioned from left to right within that contig. Browse through the
output by using the scroll bar on your Output Window to see how the accepted
readings have been arranged into contigs.

Notice that the reading names are shaded and underlined. These represent
'hyperlinks' in much the same way as web pages. If you click with the left
mouse button on a reading name using the left mouse button you will be
rewarded with a contig editor window centred on the sequence you chose. If you
click on a reading name in the output window with the right mouse button you
will be presented with a popup menu, offering several choices. (The meaning of
these choices will become more apparent later in these exercises.)

@node X3-templates
@section A Quick Introduction to the Template Display

The Template Display will be investigated fully later in these notes. However,
as many of its features are common to other graphical displays, it should make
a fleeting appearance now. Select the @b{Template Display} option from the
gap4 @b{View} pull down menu. A new dialogue window titled @i{Show templates}
takes the stage. Amongst other things, which will be investigated more closely
later, the new window offers to show the templates of all contigs (default) or
a single contig. Choose to display only a @b{single} contig by clicking on the
appropriate button. Select the contig to be displayed by clicking on the
contig lines in the Contig Selector. Note how the @i{Contig identifier} listed 
in the templay display dialogue automatically updates. End up with your
longest contig selected (@b{xb56b6.s1}) and then click on the Show templates
window @b{OK} button. The Show templates window makes way for its bigger and
more brightly decorated brother displaying the templates of the selected
contig.

@image{gap4-templates,6in}

You could have brought forth a single contig template display in a rather more
straight forward fashion directly from the @i{Contig Selector}. Why not try
it? Place your mouse over the line representing a different contig to that
already displayed. Hold down your right mouse button and select @b{Template
display} from the resultant pull down menu. You should now have two template
display windows on your screen@footnote{Note that you can also invoke the
editor for a contig from the Contig Selector in very similar fashion.}.

Moving back to your template display(s), each display offers a profusion of
blue and green lines with a few other colours too. The dark blue lines
represent templates - which is how we refer to the inserts of target DNA
cloned in the sequencing vector (@i{m13mp18}). The green lines with arrows
represent readings (and their directions) that have been sequenced from that
template. Templates that have been sequenced from both ends are drawn in a
different colour (either pink or green depending on whether the readings at
each end are within the same contig). A quick summary of the colours taken
from the manual follows.

@sp 1
@multitable @columnfractions .20 .8
@item @b{Reading Colour}
@tab @b{Meaning}

@item Red @tab Primer unknown

@item Green @tab Forwards primer

@item Orange @tab Reverse primer

@item Dark cyan @tab Custom forward primer

@item Orange-red @tab Custom reverse primer
@end multitable

@sp 1
@multitable @columnfractions .2 .8
@item @b{Template Colour}
@tab @b{Meaning}

@item Blue
@tab
Template contains only readings from one end

@item Pink
@tab
Template contains both forward and reverse readings within this contig

@item Green
@tab
Template contains both forward and reverse readings, but they are in separate
contigs

@item Black
@tab
Readings on the template are within the same contig but are in contradictory
orientations or are an unexpected distance apart

@item Yellow
@tab
Readings on the template are within different contigs and are consistent

@item Dark yellow
@tab
Readings on the template are within different contigs and are inconsistent
@end multitable
@sp 1

At the bottom of the display is a ruler representing the length of the contig
(the single black line). Try moving the mouse around one of your template
displays. You will see that each template or reading under the mouse pointer
is highlighted and a brief summary of information about that item is displayed
at the bottom of the template display window. Further information can be
obtained by pressing the right mouse button and selecting "information" from
the (very small) menu. In general most graphical displays that allow
highlighting of items also allow the right mouse button to obtain more
information or to perform operations.

Many graphical displays also have zoom controls. In such windows you will see
a @b{+10%} button, a @b{+50%} button, and a @b{zoom out} button. The +10% and
+50% buttons zoom by the stated amount, centred around the middle of the
screen (use the scrollbars if you wish to change this). To zoom by an amount
other than 10% or 50%, or to centre around another feature you may drag out a
bounding-box. This is done by first pressing the Control key and the right
mouse button. Then move the mouse to drag out the zoom box. Then releasing the
mouse button and the Control key will zoom the display so that the portion of
the window shown within the zoom box is magnified to fill the entire
window. The "Zoom out" button undoes each level of zooming in turn.

Try turning on the crosshairs, by clicking on the @b{crosshairs} button. The
precise base position under the mouse pointer can now be seen by looking in
one of the boxes in the top right corner of the window.

Start up the contig editor by moving your mouse over the Template Display
ruler and using the right mouse button@footnote{An alternative is to double
click with the middle mouse button anywhere within the template display
window}. From the pull down menu that will appear, select the @b{Edit Contig}
option. Notice that the editing cursor position is shown as a vertical
coloured line within the template display. Move the mouse (precisely) above
this line and press and hold the left mouse button. Now moving the mouse will
also move the editor in unison. Move to the contig editor and make a few tags
of any type. For variety try one in the consensus and one in a reading. Then
quit the editor, saving your changes. Once the editor is quitted and the
changes saved the template display will automatically update to reveal your
newly created tags. You may need to zoom to see them clearly. These tags will
be drawn on both the readings themselves and also on the ruler.

Once you have had enough, select @b{Exit} from the @b{File} pull down menus of
all your template displays and editor windows. Get back to having just the
Contig Selector and main gap4 window in view.

@node X3-contiguation
@section Contiguation

@subsection  Finding read pairs to search for possible contig overlaps (also to order and correctly orient contigs)

To encourage good practice, before every major editing stage, we will make a
backup copy of the database, so that if things go wrong you have a sane and
reasonably recent position to which to return. As you did previously, select
the @b{Copy database} option from the @b{File} pull down Menu. When gap4 asks
which @code{New version character} to type in @b{1}, as we are already editing 
version 0, and click on @b{OK}.

You should now have two versions of your database. The backup, 1, which is
ready should you foul up whilst contiguating, and 0, which should still be the
currently open database (check that it is the one referenced in the top bar of
your gap4 window).

If a @i{template} (insert) has been sequenced from both ends, the two readings
are called a @i{read-pair}. If the sequencing templates were size selected,
then we have an expected relative orientation and separation for read-pairs in
the final assembly. The relevant information is encoded in the Experiment
files and copied into the gap4 database during assembly. gap4 can make good
use of the read-pairs during an assembly project.

Select the @b{Find read pairs} option from the @b{View} pull down menu and
accept the default of looking in @b{all contigs} for pairs of reads from the
same template. Running the find read pairs option will expand the contig
selector into a 2D plot (called the @i{contig comparator}) to produce a graph
displaying blue lines showing the positions of the readings at each end of the
template. Forward-reverse reading pairs contained entirely within a contig are
not shown on this display, but are listed in the textual output.

Pressing the middle mouse button (or the alt key in conjunction with the left
mouse button@footnote{ As a general rule, we prefer to use a 3 button
mouse. However wherever the middle mouse button may be used it is also
possible to use alt and the left mouse button.}) with the mouse immediately
over a @i{contig line} shown in the horizontal portion of the contig selector
allows you to pick up and drag the contig around. Moving the mouse and
releasing the button then drops the contig, along with any graphical items
associated with this contig, in its new position. By doing this and using
complement contig@footnote{Either use the Complement a contig option from the
Edit pull down menu, or put the mouse over the contig in the Contig Selector
and use the right hand mouse button.} it may be possible to correctly orient
the contigs into their real order. However using the Template Display provides
a far more intuitive means of achieving this, as you will soon see.

Note that the data for this project is simply an extract of a much larger
project. The complete project is a cosmid and so for the real data we would
expect two contigs to contain tags marking cosmid vector. This also helps to
orient the contigs. Unfortunately our sub-project contains no cosmid vector
tags, but recall that the contig in exercise 2 started with a pink region
marking the cosmid vector.

@image{gap4-comparator,5in}

Pressing the right mouse button on a read pair match shown in the comparator
window will pop up a menu containing the option @b{Invoke template
display}. This command brings up a template display window again, but this
time just showing the two contigs spanned by this template. The rulers at the
bottom of this plot will be positioned by assuming that the template size is
half way between our minimum and maximum sizes specified in pregap4
(1400..2000, which implies 1700 bases). From this plot we can then see which
readings are likely to overlap if we re-sequenced them as long readings, or
performed an "oligo walk" from them.

It also illustrates the point that the template display can show multiple
contigs. Shut down your existing template display(s) and try using the main
gap4 @b{View} menu once more to select the @b{Template Display} option. This
time however elect to show @b{all contigs} and press @b{OK}. You should then
get a template display showing all contigs, all templates, and all
readings. Just like in the contig selector we can use the middle mouse button
to "pick up" and "drop" the contigs shown in the ruler plot at the bottom of
the window. This provides a useful (and in my opinion far easier) alternative
to using the read-pair plot for reordering your contigs. To make life easier,
from the template display @b{View} menu select @b{Show only spanning read
pairs}@footnote{You may have noticed that we could have chosen this option in
the initial dialogue, before pressing @b{OK}. This is just for convenience -
there is no difference otherwise.}.

You'll now be seeing far fewer template lines; four if all goes according to
plan. Now by reordering the contigs, and/or complementing contigs (by clicking 
the right mouse button over a contig in the ruler) you should be able to get
all of your readings (the arrowed items at the end of the template lines)
pointing towards one another and the correct distance apart. When this has
been achieved you will be rewarded with a plot showing only bright yellow
template lines. This is not a particularly easy task and it is not even
needed unless you want to get a mental picture of how the assembly is
progressing. So give it a try, but do not worry if you get stuck at this
point. Note that with this data a total solution is not possible as not every
contig shares a template with at least one other contig and their are two
isolated "groups" of contigs with no shared template.

It should be emphasised that manually ordering your contigs is not at all
necessary to Gap4 as the contig comparison functions (such as Find Internal
Joins, coming up next) compare all contigs to all contigs and not just the
"neighbouring" ones. If however you have a personal desire to get your contigs 
in order then you would expect the multiple-contig template display to contain
only yellow "spanning templates" and for the read-pair plot to only have blue
lines approximately forming a single diagonal line from the top left to the
bottom right with each read-pair line being parallel to this diagonal.

@subsection Finding contigs that seem to overlap, and joining them.

Here we will look at ways of getting gap4 to look at the contigs in your
database and indicate to you where contigs may potentially be joined. This can
be done in several ways and one of the most useful employs the @b{Find
internal Joins} option, which can be selected from the main gap4 @b{View} pull
down menu.

@subsubsection Finding internal joins, using only revealed data. 

The @b{Find internal joins} (FIJ) function brings up an alarmingly large
dialogue, but fortunately often little needs changing. Click on the @b{Help}
button at the bottom of the dialogue window and a web browser will display the
complete explanation for all the options offered. We will confine these notes
to the bare essentials. FIJ searches for overlaps between contigs in either
the used or the hidden data. Generally overlaps are between the end of one
contig and anywhere in another. This can be adjusted by selecting the
@b{task}. For now, we will leave this as @b{Probe all against all}.

An important feature is the ability to mask out certain segments of sequence
such as known repeats to prevent spurious matches being reported. This can be
controlled using the @b{Select Mode} section of the dialogue. This data
has no large repeats so this option is not required.

We would like to make the best joins first and then examine the poorer
joins@footnote{The same general philosophy as used for automatic contig
assembly, i.e. strict assembly criteria first to assure the best data is
assembled ahead of the poorer quality reads.}. So initially we run find
internal joins using the non hidden data. Accordingly, set @b{Use hidden data}
option to @b{No}.

Next comes the selection of @b{Alignment algorithm}. It is not necessary to
understand exactly how these work, but within find internal joins we are given
the choice between @b{sensitive} and @b{quick} methods. Alignments can be slow
to compute, especially large ones. The quick method is ideal for very long
alignments, such as when we have imported data from an adjoining database. For
our small project (with rather dubious quality sequence) the @b{sensitive}
method is best to use, so select it now.

@image{gap4-fij,3in}

The other parameters can be left untouched. Pressing @b{OK} will then display
a series of alignments between contigs in the output window and black lines in
the contig comparator showing matches between contigs.

If you still have the read pairs plot visible on screen then these
@b{@i{could}} be removed by either using the @b{clear all} command of the
@i{contig selector} (and replotting the joins) or by using the @b{Results
manager} (@b{View} menu). Do not do this, as the read pairs display is very
helpful when deciding whether a join is real or not@footnote{You should see
that most of the four potential joins found are between contigs containing
correctly oriented read pairs.}.

The results manager is an important tool for providing information on the
current plots shown. When edits are made (and saved) the plots listed in the
results manager will automatically update. Never removing plots is a bad idea
as this consumes extra memory and slows down updates. We recommend reading the
on-line help on this topic for a clearer description. To experiment with the
@b{result manager} try pressing the right mouse button on the find read pairs
result listed in the result manager and selecting @b{Configure}. From here you 
can adjust the colours and line widths. Cancel (or OK) this when you have
finished.

Try moving the mouse over the spots in the contig comparator. You will see
that each one you touch will highlight itself and the vertical and horizontal
contigs they originate from. Like the Template Display extra information is
displayed at the bottom of the window. Once again moving the mouse above a
spot in the comparator window and pressing the right mouse button will display
a popup menu containing a variety of commands.

At this stage we could use the right mouse button to select @b{Invoke join
editor} from each (black) match in turn. However a quicker strategy is to hit
the @b{Next} button at the top left of the Comparator window. This will bring
up the join editor on the best looking match. Pressing @b{Next} again will
then bring up the join editor on the next best match, and so on. If you need
to reset the Next button to start again, use the @b{Results} menu at the
top of the Contig selector window. From there select @b{Find internal joins}
and then @b{Reset 'Next'}. The @b{Results} menu may also be used for switching
the Next button between the various displayed plots, such as for our read
pairs plot (in which case Next will bring up template displays).

@image{gap4-joins,6.3in}

Having pressed @b{Next} once you should find yourself faced with a @i{Join
Editor} window. This is simply two contig editor windows stacked on top of one
another with a difference (@b{Diffs}) line between the two. Your aim is to
check whether this is really a join and to make sure it aligns properly. Don't
worry about precise correction of all errors as this will be done later, once
we've contiguated. Some useful hints include:

@itemize @bullet
@item
It is always best to start at the left hand end of your overlap and work
towards the right hand end. If you work from right to left, every time you add
or delete a character the alignment that you have just worked on will become
unaligned.

@item
Use the lock mode (the default)! Particularly if, when the editor first
appears, you cannot see the left hand end of one of your contigs. You can turn
lock mode off and on by clicking on the @b{Lock} button. Try it, but make sure
you end up with lock mode on. You can lock or unlock the two contigs together
by clicking on the button in either contig editor (this button is not present
in the single contig editor). In lock mode, when you move your display both
contigs will shift in unison. Now you can move them until a left hand end
appears. You may then need to unlock the contigs so that you can align the
extreme left end of the contig to the other sequence - but see the next point
for a quicker solution.

@item
Try the @b{Align} button. This should do most of the work for you, even if the
left end is slightly out of alignment (it'll shift the contigs
slightly). Often the FIJ algorithm has identified an approximate match, but
the Join Editor may not be showing the exactly aligned point. We suggest that
you always press @b{Align}, unless you suspect that the overlap may be huge
(in which case computing the full alignment may take a while).

@item
If you make a mistake, use the @b{Undo} buttons. There are @i{two} undo
buttons (one for each editor) so if the @b{Align} button edits both contigs
both undo buttons must be used. Of course if the alignment reveals that
the contigs do not overlap then you do not need to undo the edits as quitting
the join editor will also do that. (Just like the contig editor, it doesn't
save the edits until you quit and accept the join.)

@item
Now move along the two contigs editing as you will to align the two consensus
sequences until you get to the end of the bottom contig.

@item
It is a good idea to at least have a look to check that the overlap extends
into the hidden data (i.e. use the @b{Cutoffs} buttons). If there is no
hidden data other than sequence vector then don't worry. Remember to look at
both ends.

@item
Check the traces when there are several differences. Typically the differences
are due to base calling problems, but they may not be. If the differences are
due to "@b{-}" in the base calling then you already know that the data is bad,
but pay close attention when the base calls themselves differ. If we had
proper confidence values for this data we would also check those
@end itemize

Once your contigs are convincingly aligned, click on @b{Quit} button of either
contig editor and elect to @b{Make} the @b{join} by answering @b{Yes} to the
posed question. Gap4 will tell you what percentage mismatch remains in the
overlapping region. This figure does not take hidden data into account.

Proceed to make the joins found. Hopefully, you will agree that they all look
believable@footnote{Even the one(s) not supported by a read pair.}. If all has
gone to plan, all the joins should be correct. One looks bad at the very
end. Closer examination will reveal that this is because the sequence vector
has not been clipped completely. Tag it and adjust the cutoffs. It is perhaps
worth pointing out at this stage that the missed vector is due to a misnaming
of this sequence. The offending sequence, @b{xb54b12.r1}, claims to be a
reverse reading, but the vector we can see is the forward primer (to cut-site)
sequence. This arose purely due to our (the course instructors) attempts to
fiddle the data to obtain interesting read-pair data@footnote{In vector_primer
mode vector_clip discovers our fiddling and clips this reading correctly!}. At
the end of this stage there should be 2 contigs.

This done, use the @b{Results manager} to hide or remove the read pairs
display and then reselect the @b{read pairs} option. You should see that there
is a read pair suggesting that the remaining two contigs can be joined
sensibly. Get rid of any old show template windows you may have open and then
select @b{invoke template display} for the one read pair now displayed in the
contig comparator. Get the help for the template display and see if you can
understand completely what is being displayed@footnote{ In a nutshell, the red
lines indicate two read pairs within one contig (and one in another). The
yellow line indicates a read pair spanning the two contigs. Everything is in
the right orientation and thus all is well.}. Leave this display up.

@subsubsection Finding internal joins, using hidden data.

Select the @b{Find Internal Joins} option once again. This time elect to
@b{Use hidden data} (the default), still using the @b{sensitive}
algorithm. You are now searching through the poorer quality cutoff data at the
ends of contigs to attempt to find any less obvious joins. In this case none
should be found, but this is still an important step to perform in a
sequencing project. We will use this option more later.

@subsection Suggesting and assembling long reads

@subsubsection Suggest long readings on each contig.

When using automated sequencing machines we can rerun some of our readings as
'long readings' at a cost of slower and more expensive sequencing. The long
readings use the same universal primers as the original readings but hopefully
provide more usable sequence. Hence they can help to join contigs.

Try using the contig editor or template display to find likely candidates for
resequencing for your two contigs. Then run the @b{Suggest long readings}
command (@b{Experiments} menu) and verify the results it gives. The suggestion
function will list experiments for the single stranded regions too, but at
present we are mainly interested in contiguating.

Some contigs may have no suitable readings for resequencing. In this case we
can either select an oligo for primer-walking (more on this later) or hope
that extending one of the other contigs will suffice.

The suggest long reads facility looks at both ends of both contigs plus data
in the middle (single stranded holes) to suggest solutions.

As far as contiguation goes, we are interested in ones between the two
contigs. E.g.:

@example

Prob 2221..2221:Extend contig end for joining.
    Long     xb62h4.s1  1543. T_pos=164, T_size=1400..2000 (1700), cov 22
    Long     xb63e7.s1  1704. T_pos=187, T_size=1400..2000 (1700), cov 183
    Long     xb61d9.s1  1723. T_pos=169, T_size=1400..2000 (1700), cov 202
    Long    xb60h12.s1  1763. T_pos=377, T_size=1400..2000 (1700), cov 242
    Long    xb60d10.s1  1792. T_pos=401, T_size=1400..2000 (1700), cov 271
    Long    xb60b12.s1  2062. T_pos=160, T_size=1400..2000 (1700), cov 541

-- Searching contig xb56b6.s1 --

Prob 1..1:Extend contig start for joining.
    Long     xb56b6.s1   306. T_pos=306, T_size=1400..2000 (1700), cov 395
    Long    xb62d10.s1   173. T_pos= 97, T_size=1400..2000 (1700), cov 528
    Long    xb63f10.s1   328. T_pos=245, T_size=1400..2000 (1700), cov 373
    Long     xb58f4.s1   260. T_pos=176, T_size=1400..2000 (1700), cov 441
    Long     xb64a1.s1   579. T_pos=247, T_size=1400..2000 (1700), cov 122
    Long     xb66a5.s1   698. T_pos=324, T_size=1400..2000 (1700), cov 3
    Long     xb58d7.s1   492. T_pos= 39, T_size=1400..2000 (1700), cov 209
@end example

Some of the suggested experiments have been performed and the resulting
readings are available. They are: @b{xb56b6.s1L} and @b{xb60b12.s1L}, plus a
couple of others.

@subsubsection Obtaining a set of long reads

Lots of tedious wet stuff in "real life", but here you can simulate the long
read experiments with a simple file copy. This time copy all of the files from
the @b{course/data/long_reads/} subdirectory of the Staden Package installation
into your @b{exercise3} _ifdef([[_unix]],[[directory:]])[[]]_ifdef([[_windows]],[[folder.]])[[]]

_ifdef([[_unix]],[[@example
cp $STADENROOT/course/data/long_reads/* .
@end example
]])

The nomenclature used with this data is to add an @b{L} to the end of the
sequence name. This serves no real purpose for pregap4 or gap4, but it acts as
a useful visual guide to us - the users - when editing.

Once more, these sequences have already been passed through pregap4. In real
life we would now have a set of (for example) ABI sequence files to
process. Having set up pregap4 once for the initial shotgun pre-processing we
could then use the same pregap4 set-up to process the long readings.  With the
files you copied you should see several files starting with
@b{long_reads}. This was the output prefix used in the pregap4 run, so
@b{long_reads.passed} is the all-important file.

@subsubsection Assembling the long reads with 8% maximum mismatch

Next we should assemble the @b{long_reads.passed} file at @b{8%} mismatch. We
wish to add these long readings into our existing assembly project, so do not
create a new database. Each assembly is additive, so simply use the @b{Normal
Shotgun Assembly} option again from our current two-contig version of the
database.

There are only a few long gel readings to enter and they should all be entered
fine. Unfortunately they have not caused any more joins, so we should now move
on to Find Internal Joins to look for these.

@subsubsection Using FIJ on the database after long reads have been entered

Proceed as we did in the initial assembly: first use @b{Find Internal Joins}
on the visible data and then on the hidden data, both times using the
sensitive alignment algorithm. Searching the visible data should find no
matches. However, FIJ using hidden data should find one match. The join is
weak and in the hidden data, hence its plotted result is barely visible in the
Contig comparator window so we suggest that you use the @b{Next} button once
more. You will see that the used non-hidden portion of the contigs do not
overlap at all, so you will have to extend the quality clip point on at least
one reading in order to make an overlap. A look at the traces should give
you some confidence that the join is real.

It is time to make a further backup to version 2, when you have reached the
one contig stage.

@subsection Checking the assembly is correct using Find Read Pairs and the Check Assembly function.

The assembly can be checked at a high level by examining the read-pair
data. Assuming the information supplied to gap4 was correct (often it contains
errors caused by readings being misnamed), all the readings involved in
read-pairs should be in the right relative orientation, and within the
expected separation range. To perform this check, either read the textual
output of Find Read Pairs, or visually inspect the data using the Template
Display.  To check how well the assembly is confirmed by read-pairs use the
@b{Read-pair coverage histogram} (main @b{View} menu) function. This displays
a simple graph showing how many different consistent read pairs confirm the
assembly of each consensus base. For this assembly all the data is confirmed
except for the contig ends.

Next check the quality of the alignment of the readings, and that they extend
well into the hidden data. If your project contains repeats, it may be that
the assembly engine has put some readings in the wrong place. To perform this
analysis use @b{Check Assembly} (main gap4 @b{View} menu) in each of its
modes. First, answer @b{No} to @b{Use cutoff data}, which tells gap4 to only
use the visible parts of the readings. Keep @b{15%} as the mismatch level and
press @b{OK}. You should see several lines drawn along the main diagonal of
the Contig Comparator. Each represents a reading whose alignment against the
consensus contains at least 15% mismatches. Pressing the @b{Next} button will
bring up the @b{Contig Editor} with the editor cursor over the reading with
the highest proportion of mismatches. Try turning on the @b{Highlight
Disagreements} function from the @b{Settings} menu (we prefer background
colour mode) to easily identify the causes of the poor alignment. A useful tip
is to left-click on the reading name to mark it in inverse-colour. This means
that you can visually keep tabs on the problematic reading as you scroll along
the editor. When you have satisfied your curiosity (and fixed the problems if
you wish) you do not need to quit the editor. Just hit @b{Next} again in the
Contig Comparator window and the editor will automatically jump to the next
worst reading. In all cases it seems that the assembly is correct, but the
quality of the data is poor, possibly requiring adjustments to the 5' clip
points.

After you've looked through the problems in the visible data, try @b{Check
assembly} again, but this time including the @b{cutoff data} (but use @b{20%}
mismatch). There will be a similar number of results. However as these
alignment problems are in the hidden data, it is not too easy to identify them
using the editor (try if you wish - the "next" button works as before). The
best place to look is the main gap4 @i{text output} window. We expect a
gradual deterioration as the quality of the traces, and hence the base
calling, drops, however any sudden divergence in the quality of an alignment
may indicate a problem, such as an unidentified repeat.

@node X3-finishing
@section More Finishing functions.

Having got your contigs joined, in the correct orientation and order, it is
now time look at each remaining contig (just one for this data) and start to
do some final editing. This is the most labour intensive editing stage and
should only be undertaken when all other larger scale editing has been
completed. Only at this stage is it possible to identify the edits that are
really essential, and thus to spend time on only those.

The first two procedures we will look at are designed to improve the alignment
of the readings and to increase the amount of the consensus that is covered by
data on both strands.

@subsection Shuffling the pads within your contig

Start by bringing up the contig editor once more. In this editing procedure,
gap4 takes a second look at the way it inserted padding characters into your
readings, and attempts to make a neater job of things. Nothing other than the
positions of padding characters are altered, which makes this a relatively
safe editing process. First move along your contig until you find a nice
candidate region for shuffling pads. Look out in particular for regions in
which gap4 inserted padding characters irregularly. For example@footnote{If
this proves difficult, try looking around the 3' end of @b{xb60g4.s1}. Use the
editor @b{Next Search} (by @b{reading name}) option to find this reading. The
editor cursor will immediately jump to the left end of this reading. If you
happen to have the reading complemented then you will need to view the right
hand end, in which case the @b{Control-E} key combination will help. Look at
the help for a full list of keyboard shortcuts. }:

@multitable @columnfractions .25 .5 .25
@item @code{...GAAAG...} @tab @tab @code{...GAAAG...}
@item @code{...G*AAG...} @tab instead of the somewhat tidier @tab @code{...G*AAG...}
@item @code{...GAA*G...} @tab @tab @code{...G*AAG...}
@end multitable

@image{gap4-editor4,6.3in}

Whilst watching carefully the messy region of your contig, select the
@b{Shuffle pads} option from the @b{Commands} pull down menu of your Contig
editor window. It may help to scroll the editor slightly so that the menu does
not obscure your view, or to use the "- - - - -" tearoff line to place the
menu elsewhere on the screen. You should see the messy pads shuffle themselves
around to look much much prettier. If you didn't quite catch what it did (or
you really enjoyed the first run) then use @b{Undo} and then go for a repeat
performance. This function reduces the number of manual edits required. Note
that Shuffle Pads processes the whole contig, and we only suggested looking at
a particular region so that you could observe the effect.

@subsection Quality plot and Double stranding

The next editing function to have a look at attempts to automatically improve
regions of contigs covered only by readings of one strand of the target
DNA. The "improvement" is effected by attempting to "extend" overlapping
readings from the unrepresented strand@footnote{ Thus moving a little closer
to the ideal minimum of having all regions of a consensus sequence represented
by reads from each strand.}. Readings are extended by revealing any portions
of "hidden" sequence from the end of the read@footnote{ In theory, extending
backwards from the beginning of a read would always extend into vector, so
extensions are not sought in this direction.} that can be believably aligned
with the single stranded portions of the contig.

@image{gap4-quality,6in}

Bring up the @b{Template display} and turn on the @b{Quality plot} (template
display @b{View} menu). The @b{Quality plot} may also be brought up as a
separate plot (main gap4 @b{View} menu) if you prefer a less cluttered
screen. Note that here the term "quality" is a little dated; the plot is
categorising each consensus base by the existence and agreement of data on
both strands. It does not check the confidence values assigned by programs
such as phred and ATQA. See the help for a precise description of the colours
and heights used in the plot. In general, a single grey horizontal line
represents zero conflicts and data on both strands. You may wish to zoom up to
see the plot more clearly. The @i{Output Window} will have a text summary of
the quality of the contig. For our data this claims:

@example
Contig xb63c10.s1 (#60)
 77.51 OK on both strands and they agree(a)
  8.32 OK on plus strand only(b,d)
 12.31 OK on minus strand only(c,e)
  1.41 Bad on both strands(f,g,h,j)
  0.45 OK on both strands but they disagree(i)
@end example

Bring up the @b{Contig editor} from one of the 'single stranded' regions
identified in the quality plot. This can be done by a swift double-clicking of
the left or middle mouse button in the quality plot, and then if required
dragging (left or middle mouse button) the editor cursor-line shown in the
quality plot. You should find, around one end of sequence @b{xb63c7.s1}, a
short single stranded segment. Try turning on @b{Show strands} in the contig
editor. This can be found in the @b{Settings} menu, cascading into @b{Status
Line}. The plus and minus symbols indicate single stranded segments. Look at
the hidden data to see which readings will "cover" this single stranded
"hole". The most obvious reading is @b{xb63c7.s1} itself, however the quality
is terrible. @b{xb66d5.s1} is a much better quality reading and even though it
requires many more bases to be uncovered, doing so will double strand the
region by introducing the fewest number of discrepancies. Now shut down the
editor, as the double stranding function refuses to make changes if you're
already editing the contig yourself.

With the quality plot still visible run the @b{Double Strand} function (main
@b{Edit} menu) on @b{all contigs}. The various options listed in the dialogue
control how bad the data has to be before Double strand stops using it. Once
the Double Strand function has finished the quality plot should update itself
showing the improvements. If the difference is not readily apparent use the
result manager to request for information on the "calculate quality" result
(or just wimp-out and remove and re-plot the quality plot). This will produce
a new text summary in the Output Window, hopefully showing an improvement in
double stranded data by several percent. In our data this now shows:

@example
Contig xb63c10.s1 (#60)
 81.63 OK on both strands and they agree(a)
  6.79 OK on plus strand only(b,d)
  9.52 OK on minus strand only(c,e)
  1.41 Bad on both strands(f,g,h,j)
  0.65 OK on both strands but they disagree(i)
@end example

In other words, a 4% improvement in @code{OK on both strands} with only 0.2%
of problems introduced.

Look at the text output from Double Strand. You should see that it has indeed
decided to extend @b{xb66d5.s1} to solve the problem we saw earlier. If you
are a cynic you may wish to bring up the contig editor again to verify this.

@subsection Selecting oligos for single stranded regions. 

Even after you have used the Double strand option, there are likely to be
single stranded regions in your contigs. To resolve these one can either use
long reads (as discussed previously) or design primers to generate sequence to
cover these areas. gap4 offers an option that will automatically suggest
primers for all single stranded regions of any part of a selected contig.

Use the @b{Contig editor} to locate a single stranded region. Once again the
@b{Show strands} setting will help, or using the @b{Quality plot} to control
the contig editor cursor. Find a single stranded region in the contig
(preferably not at one of the contig ends).

If you've found a segment with no positive strand then position the editing
cursor around 40 bases leftwards of the single stranded region. Similarly, set
it to the right of any region when there is no negative strand. Hopefully now
it will be possible to produce an oligo at this point to use as a primer for
sequencing. The primer can then be used with any suitable template spanning
that region. The simplest manual method of doing this is to create an oligo
tag (OLIG) by hand and note down the sequence. A better method is to use
the @b{Select Primer} command within the editor to search for suitable oligos
(see the on-line help). The best method is to use an automatic function which
will search for and tag all oligos needed to double strand the entire contig.

This is performed by the @b{Suggest Primers} command (main @b{Experiments}
menu). Shut down the editor before running this. A file of primers and reading
names (will be template names in the future) is then produced. Unfortunately
for this test data we do not have suitable experimental results (readings)
prepared for you, but please go through the motions of getting gap4 to suggest
the experiments. Once finished you will see a variety of textual output, but
most informative is to use the @b{Template display}. This will show several new
bright yellow tags indicating the primers and readings suggested. These should
tally with the output from the quality plot.

The contig selector can show these tags in the same way as the template
display. However initially these are not shown. In the contig selector
@b{View} menu choose the @b{Select tags} option. This will create a new window
named @i{Active tags} where individual tag types can be enabled or disabled. I
suggest that the easiest solution for now is simply to click on the @b{Select
all} button followed by @b{OK}@footnote{If you wanted to make this change
permanently then, due to the lack of an @b{OK permanent} button, you need to
edit (or create) your @b{.gaprc} file in your 'home' directory and add the
following:

@example
set_def CONTIG_SEL.TAGS         @{*@}
@end example
}. Notice that you can now see the tags in the horizontal portion of the
contig selector.

@node X3-more
@section What now?

From this point onwards the general finishing procedure simply involves a
few cycles of directed sequence experiments until you are happy with the
coverage. Try to aim for sequence confirmation on both strands, or in cases
where this proves to be too hard you may be satisfied with using multiple
sequencing chemistries (e.g. both dye-primer and dye-terminator).

After this, you then need to verify that your consensus is indeed
accurate. Obviously the methods involved here will greatly depend on
whether you have confidence values available (although these days there
is little reason not to). Repeated use of list confidence and search by
consensus confidence should, in the end, yield a highly accurate consensus.

And finally, most important of all, use the @b{Save consensus} option (to be
found in the main @b{File} menu) to output @b{Normal consensus} to a
file. This may be fasta format, or if you wish also to output tags then choose
the Experiment file format. Note that you are given the option to @b{Strip
pads}, which will remove all the @b{*} characters from the consensus that is
written to disk. This means that you do not need to edit these out from the
consensus if you agree with gap4's statement that there is indeed no basecall
at such points.


